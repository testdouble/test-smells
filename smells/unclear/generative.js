/* Генерирующие тесты
 *
 * Запах: тест генерирует проверки по набору входных и выходных значений.
 *
 * Причины:
 *   1. Чаще всего генерирующие тесты пишут для функций, в которых данные
 *      и логика запутаны в ветках if/switch. Из-за того, что тестируемый
 *      модуль содержит кучу ветвлений и данных, в его тестах проверяется
 *      куча случаев.
 *
 *      Если случаи кажутся повторяющимися, естественная реакция — попытаться
 *      устранить повторы.
 *
 *      Лечение: в избыточных, повторяющихся тестах обычно виноваты не тесты,
 *               а тестируемый модуль. Сгенерированные проверки уменьшат
 *               боль, но спрячут от нас необходимость разделить данные и логику
 *               в дизайне тестируемого модуля.
 *
 *               Для начала посмотрите на структуру, по которой генерируете
 *               проверки: если бы код имел к ней доступ, это упростило бы
 *               его логику?
 *
 *               См. также: smells/unclear/chafing.js
 *
 *   2. Сравнение полученного результата с примерами покрывает часть случаев
 *      из обычно бесконечного набора входных и выходных данных. Некоторые
 *      разработчики пытаются проверить так много случаев, что идея
 *      сгенерировать проверки кажется отличной.
 *
 *      Тестирование всех возможных случаев — нереальная цель с сомнительными
 *      преимуществами. Более того, генерирование проверок может усыпить
 *      бдительность разработчиков: часто такие проверки генерируют кучу
 *      ненужных случаев и забывают о краевых или ошибочных (потому что их
 *      так просто не сгенерируешь).
 *
 *      Лечение: возьмите за правило добавлять тест, только если он упадет.
 *               Так он поможет улучшить тестируемый модуль.
 *
 *               См. также: smells/unnecessary/paranoid.js
 *
 * Замечания к примеру:
 *   Если непонятно, что делать, попробуйте извлечь объект с входными
 *   и выходными значениями и добавить его в тестируемый модуль. Если бы
 *   `toArabic` имел доступ к структуре, из которой он брал бы нужное значение,
 *   как логику в нем можно было бы упростить?
 */

// Тестируемый модуль
var _ = require('lodash')
function toArabic (roman) {
  return _(roman).map(function (x, i) {
    var nextX = roman[i + 1]
    if (x === 'I') {
      return _.includes(['V', 'X'], nextX) ? -1 : 1
    } else if (x === 'V') {
      return nextX === 'X' ? -5 : 5
    } else if (x === 'X') {
      return nextX === 'C' ? -10 : 10
    }
  }).reduce(function (memo, x) { return memo + x })
}

// Тесты
module.exports = _.transform({
  'I': 1,
  'II': 2,
  'III': 3,
  'IV': 4,
  'V': 5,
  'VI': 6,
  'VII': 7,
  'VIII': 8,
  'IX': 9,
  'X': 10
}, function (test, arabic, roman) {
  test['Roman numeral: ' + roman + ' => ' + arabic] = function () {
    assert.equal(arabic, toArabic(roman))
  }
})
