/* Пересушенные тесты
 *
 * Запах: тесты, в которых автор постарался максимально убрать повторяющуюся
 *        информацию, несмотря на то, что читателям будет тяжело понять
 *        назначение и поведение тестов.
 *
 * Причины:
 *   1. DRY ("Don't repeat yourself") — принцип дизайна ПО, из-за которого
 *      разработчики чувствуют дискомфорт при виде повторов. Когда разработчики
 *      видят повторяющийся код в тестах, срабатывает рефлекс — устранить
 *      повторы, вытащив хелперы для тестов.
 *
 *      Лечение: повторение текста бывает нужно тесту, чтобы он ясно
 *               и полноценно показывал, как проверяет тестируемый модуль.
 *
 *               Если повторение отвлекает от этого, сначала проверьте, можно
 *               ли переработать тестируемый модуль так, чтобы уменьшить
 *               количество повторов. Затем проверьте, станет ли тест более
 *               понятным, если убрать повторяющийся текст.
 *
 *               Если повторы делают тест запутанным, заинлайните хелперы
 *               (даже если это выглядит уродливо), чтобы тест показывал,
 *               как он проверяет тестируемый модуль.
 *
 *   2. Тесты используют внешние фикстуры и фабрики для создания стандартного
 *      набора моделей в интеграционных тестах. Такой подход снимает боль
 *      от тяжелой подготовки тестов с кучей зависимостей, но может быстро
 *      превратиться в свалку: больше тестов, зависящих от них, —
 *      больше сложности.
 *
 *      Становится непонятно, как тест использует тестируемый модуль.
 *      Никто не может упростить эти абстракции без того, чтобы не сломать
 *      другие тесты магическим образом.
 *
 *      Лечение: перед тем как вытащить абстракции, которые будут
                 использоваться
 *               в нескольких тестах, убедитесь, что эту проблему нельзя решить,
 *               переработав тестируемый модуль, и оцените риск того, что
 *               тесты станут менее ясными.
 *
 * Замечания к примеру:
 *   Абстракции в примере ниже (`generateCode` и `assert.codePricing`)
 *   делают тесты запутанными: непонятно, что `pricingForCode` делает.
 *   Кроме того, проверка состоит из вычислений, а `pricingForCode` из ветвлений
 *   и конкретных значений.
 *
 *   Возможно, после инлайна этих абстракций, мы увидим,как улучшить тестируемый
 *   модуль.
 */

// Тестируемый модуль
function pricingForCode (code) {
  var firstFactor = 0
  if (code[0] === 'A') firstFactor = 65
  if (code[0] === '7') firstFactor = 55
  if (code[0] === '(') firstFactor = 40

  var secondFactor = 0
  if (code.length === 3) secondFactor = 21
  if (code.length === 5) secondFactor = 19
  if (code.length === 8) secondFactor = 16

  return firstFactor * secondFactor
}

// Тесты
var generateCode = require('../../support/generate-code')
module.exports = {
  codeOneIsCorrect: function () {
    var code = generateCode.one()

    var result = pricingForCode(code)

    assert.codePricing(result, code)
  },
  codeTwoIsCorrect: function () {
    var code = generateCode.two()

    var result = pricingForCode(code)

    assert.codePricing(result, code)
  },
  codeThreeIsCorrect: function () {
    var code = generateCode.three()

    var result = pricingForCode(code)

    assert.codePricing(result, code)
  }
}
